/* Generated by: https://www.npmjs.com/package/jsfx-preprocessor */
//stripped down version of Formant Shift feature on Warble by GeraintLuff
desc:Ugly Pitch (DD)
in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:correction_semitones_global=0<-12,12,1>-transpose (semitones)
slider2:tonality_limit=0.2<0,1,0.01>-tonality limit
slider3:formant_shift_semitones=0<-12,12,0.1>-formant shift (semitones)

//import ui-lib.jsfx-inc
import DGFX/warble-pitch-detection.jsfx-inc
import DGFX/warble-delay-utils.jsfx-inc
import DGFX/tk_lib_d.jsfx-inc 

filename:0,DGFX/uglypitch/bg.png
filename:1,DGFX/uglypitch/bgmcp.png
filename:2,DGFX/uglypitch/knob.png
filename:3,DGFX/uglypitch/screw.png

options:no_meter
// write a cool name to store jsfx memory below
options:gmem=UglyPitchD  

@init
  gfx_ext_retina = 1;
  gfx_clear=0;
  lastCap=1;
  mouse_wheel=1;
  Number_input = 0;
  number_input_invalid = 0;
  number_input_x = 0;
  number_input_y=0;
  ext_noinit=1;

  // tk extra features
  lastCap=1;
  mouse_wheel=1;
  is_recording = 0; is_playing = 0; is_stopped = 1;
  while_playing = 1; while_recording = 1; while_stopped = 1;
  Number_input = 0;
  number_input_raw = 0;
  number_input_use = 0;
  komma = 0;
  in_key = 0;
  number_input_x = 0;
  number_input_y=0;
  number_input_slider = 0;
  number_input_min=0;
  number_input_max=0;
  number_input_invalid = 0;
  number_input_sign=1;
  s2_numbers_of_sliders = 10; // set the number of sliders for gorup linking
  s2_numbers_of_generics = 0;
  group_generics = 0; // fuer group_generics[bis zu 200] <-- ?
  sliders_old = group_generics + 16*200;
  generics_old = sliders_old + 16*64;

  mouse_sensivity();
  // OVERFLOW PROTECTION - if you get an overflow, increase this value.
  safe_allocation = 65536*16; // was *4

  !not_first_init ? (
    reset_shift = 0;
    display_follow_playback = 1;
    not_first_init = 1;
  );

  freemem = 0;
  //freemem = ui_setup(freemem);
  freemem = pitch_detection.pitch_detection_init(freemem);
  pitch_detection.pitch_detection_config_tonality_limit(0);
  latencysamples = pitch_detection.pitch_detection_delay();
  min_freq = 10;
  max_delay = srate/min_freq;
  freemem = delay0.delay_init(freemem, latencysamples + max_delay);
  freemem = delay1.delay_init(freemem, latencysamples + max_delay);

  formant_max_window_length = ceil(0.1*srate);
  formant_remaining = formant_max_window_length;
  formant_buffer_length = formant_max_window_length;
  formant_input_original = freemem;
  freemem += formant_buffer_length*2;
  formant_input_shifted = freemem;
  freemem += formant_buffer_length*2;
  formant_output = freemem;
  freemem += formant_buffer_length*2;
  formant_fftsize = pow(2, ceil(log(formant_max_window_length + 1)/log(2)));
  formant_fftbuffer = freemem = 65536*ceil(freemem/65536);
  freemem += formant_fftsize*2;
  formant_spectrum_original = freemem;
  freemem += formant_fftsize*0.5;
  formant_spectrum_shifted = freemem;
  freemem += formant_fftsize*0.5;
  formant_index = 0;

  analysis = safe_allocation;
  analysis_step = 4/*ANALYSIS: */;
  !analysis_interval ? analysis_interval = 0.01; // 10ms
  //analysis_count = 0;

  //freemem > analysis ? (
  //  ui_error("Overflow! Increase \"safe_allocation\" in the code, and email Geraint: luffgd@gmail.com");
  //);
  function parameters_update() (
    parameters_update_on = 1;
    group_parameters(); // tk extra features
    // Paste all contents of @slider here
    parameters_update_on = 0;
    caller = 0;
  );

@serialize // add this block for tk extra features
  file_var(0, while_playing);
  file_var(0, while_recording);
  file_var(0, while_stopped);
  //file_var(0, LA2Kan_VERSION);
  file_var(0, link_group);
  seriloop = 0;
  loop(64*16 + 27 + 16,
  file_var(0, gmem[seriloop]);
  seriloop += 1;
  );
  seriloop = 0;
  loop(200*16,
  file_var(0, group_generics[seriloop]);
  seriloop += 1;
  );

@block

  block_index = 0;

  formant_shift_semitones==0 ? correct_formants_ugly = 0 : correct_formants_ugly = 1;


  pdc_delay = latencysamples
    + (correct_formants_ugly ? formant_buffer_length : 0);
  pdc_bot_ch = 0;
  pdc_top_ch = 2;

@sample

  S2_sample_on = 1;

  // extra tk features
  gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
  group_check_smpl();

  caller == 1 ? (
    parameters_update_on == 0 ? (
      parameters_update();
    );
  );

  // extra tk features
  playstates();
  process = 0;
  while_playing ? is_playing ? process = 1;
  while_recording ? is_recording ? process = 1;
  while_stopped ? is_stopped ? process = 1;

  function calculate_spectrum(buffer, fftsize, spectrum, resolution) local(i, i2, sum, blurspan, mag2) (
    spectrum[0] = buffer[0]*buffer[0] + buffer[1]*buffer[1];
    i = 1;
    while (i < fftsize*0.5) (
      i2 = fftsize - i;
      mag2 = buffer[2*i]*buffer[2*i] + buffer[2*i + 1]*buffer[2*i + 1] + buffer[2*i2]*buffer[2*i2] + buffer[2*i2 + 1]*buffer[2*i2 + 1];
      spectrum[i] = mag2;
      i += 1;
    );

    blurspan = floor(fftsize*resolution/srate + 0.75);
    sum = 0;
    i = 0;
    while (i < fftsize*0.5) (
      sum += spectrum[i];
      spectrum[i] = sum;
      i += 1;
    );
    i = fftsize*0.5 - 1;
    while (i > blurspan) (
      spectrum[i] = (spectrum[i] - spectrum[i - blurspan])/blurspan;
      i -= 1;
    );
    while (i >= 0) (
      spectrum[i] = spectrum[i]/(i + 1);
      i -= 1;
    );

    blurspan = floor(fftsize*resolution/srate + 0.25);
    sum = 0;
    i = fftsize*0.5 - 1;
    while (i >= 0) (
      sum += spectrum[i];
      spectrum[i] = sum;
      i -= 1;
    );
    i = 0;
    while (i < fftsize*0.5 - blurspan) (
      spectrum[i] = (spectrum[i + blurspan] - spectrum[i])/blurspan;
      i += 1;
    );
    while (i < fftsize*0.5) (
      spectrum[i] = spectrum[i]/(fftsize*0.5 - i);
      i += 1;
    );
    i = 0;
    while (i < fftsize*0.5) (
      spectrum[i] = sqrt(spectrum[i]);
      i += 1;
    );
  );

  function move_from_input_to_buffer(fftsize, window_length, input, spectrum, resolution) (
    i = 0;
    centre_index = max(formant_max_window_length*0.5, formant_max_window_length - window_length*0.75);
    centre_index = formant_buffer_length*0.5;
    while (i < fftsize) (
      window_ratio = (i - centre_index)/window_length;
      window_ratio < 0.5 ? (

        i2 = formant_index + i;
        i2 >= formant_buffer_length ? (
          i2 -= formant_buffer_length;
        );

        window_value = (window_ratio < 0) ? 1 : 0.5 + 0.5*cos(window_ratio*2*$pi);

        // Move from input to fft buffer
        formant_fftbuffer[2*i] = input[2*i2]*window_value;
        formant_fftbuffer[2*i + 1] = input[2*i2 + 1]*window_value;

        input[2*i2] *= (1 - window_value);
        input[2*i2 + 1] *= (1 - window_value);
      ) : (
        formant_fftbuffer[2*i] = formant_fftbuffer[2*i + 1] = 0;
      );
      i += 1;
    );

    // TODO: maybe we don't always need an FFT this big - could pass in FFT size to this function
    fft(formant_fftbuffer, fftsize);
    fft_permute(formant_fftbuffer, fftsize);
    calculate_spectrum(formant_fftbuffer, fftsize, spectrum, resolution);
  );
  
  process==1?(
    seconds = play_position + block_index/srate;

    // Pitch-detection for shifting and analysis
    pitch_detection.pitch_detection_input(spl0, spl1);

    // Shifting
    index_float = seconds/analysis_interval;
    index_int = floor(index_float);
    index_ratio = index_float - index_int;
    entry = analysis + index_int*analysis_step;
    entrynext = entry + analysis_step;
    correction_semitones = entry[3/*ANALYSIS:SHIFT_SEMITONES*/]*(1 - index_ratio) + entrynext[3/*ANALYSIS:SHIFT_SEMITONES*/]*index_ratio + correction_semitones_global;
    index_int >= analysis_count || reset_shift ? (
      correction_semitones = correction_semitones_global;
    );

    //formant_shift_semitones = 0;
    formant_shift_factor = pow(2, formant_shift_semitones/12);

    freq = pitch_detection.pitch_detection_freq();
    tonality = pitch_detection.pitch_detection_tonality();
    tonality < tonality_limit ? (
      correction_semitones *= tonality/tonality_limit;
    );

    wavelength = srate/max(min_freq, freq);
    correction_factor = pow(2, correction_semitones/12);
    correction_freq = freq*(correction_factor - 1);
    freq > min_freq && abs(correction_freq) > 1 ? (
      phase += correction_freq/srate;
    ) : phase > 0.001 ? (
      // Slew towards 1
      phase += (1 - phase)*max(correction_freq, 1)/srate;
    );
    while (phase > 1) (
      phase -= 1;
    );
    while (phase < 0) (
      phase += 1;
    );

    // Implement cross-fading delay
    delay0.delay_input(spl0);
    delay1.delay_input(spl1);
    delayA = latencysamples - phase*wavelength;
    delayB = delayA + wavelength;

    formant_input_original[2*formant_index] = delay0.delay_output_linear(latencysamples);
    formant_input_original[2*formant_index + 1] = delay1.delay_output_linear(latencysamples);

    // Cubic fade between the two
    phase_factor = phase*phase*(3 - 2*phase);

    spl0 = delay0.delay_output_linear(delayA)*(1 - phase_factor) + delay0.delay_output_linear(delayB)*phase_factor;
    spl1 = delay1.delay_output_linear(delayA)*(1 - phase_factor) + delay1.delay_output_linear(delayB)*phase_factor;

    formant_input_shifted[2*formant_index] = spl0;
    formant_input_shifted[2*formant_index + 1] = spl1;

    analysis_index_ratio = floor(seconds/analysis_interval);
    analysis_index = floor(analysis_index_ratio);
    analysis_index_ratio -= analysis_index;
    (analysis_index == analysis_index_prev + 1)? (
      // Add clean entries to the analysis table
      while (analysis_count < analysis_index + 1) (
        analysis_entry = analysis + analysis_step*analysis_count;
        analysis_entry[0/*ANALYSIS:INPUT_FREQ*/] = analysis_entry[1/*ANALYSIS:INPUT_AMP*/] = analysis_entry[2/*ANALYSIS:INPUT_TONALITY*/] = analysis_entry[3/*ANALYSIS:SHIFT_SEMITONES*/] = 0;
        analysis_count += 1;

        // Stretch view if we're adding more
        display_left_time = min(display_left_time, seconds);
        display_right_time = max(display_right_time, seconds);
      );
      analysis_entry = analysis + analysis_step*analysis_index;
      analysis_entry[0/*ANALYSIS:INPUT_FREQ*/] = pitch_detection.pitch_detection_freq();
      analysis_entry[1/*ANALYSIS:INPUT_AMP*/] = pitch_detection.pitch_detection_amp();
      analysis_entry[2/*ANALYSIS:INPUT_TONALITY*/] = pitch_detection.pitch_detection_tonality();

      reset_shift ? (
        analysis_entry[3/*ANALYSIS:SHIFT_SEMITONES*/] = 0;
      );
    ) : (analysis_index != analysis_index_prev) ? (
      reset_shift = 0;
    );

    (play_state&1) ? block_index += 1;
    analysis_index_prev = analysis_index;

    formant_index += 1;
    formant_index >= formant_buffer_length ? (
      formant_index = 0;
    );



    correct_formants_ugly ? (
      formant_remaining -= 1;
      formant_remaining <= 0 ? (
        //window_length = max(ceil(0.01*srate), min(formant_max_window_length, wavelength*10));
        window_length = formant_max_window_length*0.75;
        //fftsize = min(formant_fftsize, pow(2, ceil(log(window_length*2)/log(2))));
        fftsize = formant_fftsize;
        formant_remaining += window_length*0.5;

        resolution = max(max(freq, freq + correction_freq), min_freq);
        move_from_input_to_buffer(fftsize, window_length, formant_input_original, formant_spectrum_original, resolution);
        move_from_input_to_buffer(fftsize, window_length, formant_input_shifted, formant_spectrum_shifted, resolution);

        factor = (formant_spectrum_original[0]/formant_spectrum_shifted[0])/fftsize/formant_shift_factor;
        formant_fftbuffer[0] *= factor;
        formant_fftbuffer[1] *= factor;

        formant_fftbuffer[fftsize] = 0;
        formant_fftbuffer[fftsize + 1] = 0;
        i = 1;
        while (i < fftsize*0.5) (
          i2 = fftsize - i;
          i_formant = min(fftsize*0.5 - 1, floor(i/formant_shift_factor + 0.5));
          factor = (formant_spectrum_original[i_formant]/formant_spectrum_shifted[i])/fftsize/formant_shift_factor;
          formant_fftbuffer[2*i] *= factor;
          formant_fftbuffer[2*i + 1] *= factor;
          formant_fftbuffer[2*i2] *= factor;
          formant_fftbuffer[2*i2 + 1] *= factor;

          i += 1;
        );
        fft_ipermute(formant_fftbuffer, fftsize);
        ifft(formant_fftbuffer, fftsize);

        // Copy to output
        i = 0;
        while (i < formant_buffer_length) (
          i2 = formant_index + i;
          i2 >= formant_buffer_length ? (
            i2 -= formant_buffer_length;
          );
          window_ratio = (i + 0.5)/formant_buffer_length;
          window_value = 0.5 - 0.5*cos(window_ratio*2*$pi);
          window_value /= (1 + 0.999*(window_value - 1));

          formant_output[2*i2] += formant_fftbuffer[2*i]*window_value;
          formant_output[2*i2 + 1] += formant_fftbuffer[2*i + 1]*window_value;
          i += 1;
        );
      );

      spl0 = formant_output[formant_index*2];
      spl1 = formant_output[formant_index*2 + 1];
      formant_output[formant_index*2] = formant_output[formant_index*2 + 1] = 0;
    );
  );


<? // @gfx setup
  w_bg=512;
  h_bg=216;
  mcp_ratio="wide";
  include("ddconfig.jsfx-inc");
?>
  tk_gfx_setup();
  gfx_ext_flags == 0 ? (  // full ui
    set_background(0);
                                    //mode=0 you manually write your code for handling mouse input; mode=1 automatic handling
    //Knobs                      (slider    default     min      max     step           x            y   frames  scaling   png  mode  reverse) (frames = 0 = auto calculate)   (step=0=default floating numbers as step)   
    kPitch.parameter_config      ( 1,             0,    -12,      12,       1,       130/2,        72/2,     0,       1,     2,    1,       0);    
    kTonality.parameter_config   ( 2,           0.2,      0,       1,    0.01,       251/2,       105/2,     0,       1,     3,    1,       0);    
    kFormant.parameter_config    ( 3,             0,    -12,      12,     0.1,       310/2,        72/2,     0,       1,     2,    1,       0);    
    //gfx_r=0.616;gfx_g=0.569;gfx_b=0.141;
    gfx_r=gfx_g=gfx_b=1;
    gfx_a=0.4;
    kPitch.attached_label("PITCH",-2, "Helvetica",12,'');
    //kTonality.attached_label("TONE",0, "Helvetica",7,'b');
    kFormant.attached_label("FORMANTS",-2, "Helvetica",12,'');

    setup_dmenu("UglyPitch fom Warble by Geraint Luff", "1", "Analog Obsession, Tukan Studios, Pitufodelbosque, ReArtist", 0.2); // setup menu, arguments: jsfx name, version, graphics, zoom

    mouse_wheel=0;
  ):gfx_ext_flags == 1 ? ( // embedded mcp ui
    set_background(1,0.043,0.043,0.043);
    kPitch.parameter_config      ( 1,             0,    -12,      12,       1,       40/2,        63/2,     0,       1.2,     2,    1,       0);    
    kFormant.parameter_config    ( 3,             0,    -12,      12,     0.1,       145/2,        63/2,     0,       1.2,     2,    1,       0);   
    kTonality.parameter_config   ( 2,           0.2,      0,       1,    0.01,      132/2,       105/2,     0,       1.2,     3,    1,       0);    
    gfx_r=gfx_g=gfx_b=1;
    gfx_a=0.4;
    kPitch.attached_label("PITCH",-4, "Helvetica",16,'b');
    //kTonality.attached_label("TONE",0, "Helvetica",7,'b');
    kFormant.attached_label("FORMS",-4, "Helvetica",16,'b');
    mouse_wheel=0;
  );
  
  // update parameters
  S2_sample_on == 0 ? (
  gmem[16*64 + 10 + link_group] != 1 ? link_group = 0; // tk extra features
  group_check_gfx(); // tk extra features
    caller == 1 ? (
        parameters_update_on == 0 ? (
          parameters_update();
        );
    );
  );
  S2_sample_on = 0;

