desc:tukans library demian d mod




@init

function round(dnumber)(
	dnumber=dnumber+0.5;
	dnumber=floor(dnumber);
	dnumber;
);

	function tk_gfx_setup() (
		mouseHold = mouse_cap & 1;
		press_superkey = mouse_cap & 32;
		press_ctrl = mouse_cap & 4;
		press_shift = mouse_cap & 8;
		press_alt = mouse_cap & 16;
		superkey=ctrl=shift=alt=shift_alt=shift_ctrl=shift_superkey=alt_superkey=ctrl_superkey = 0;
		press_superkey ? !press_ctrl ? !press_shift ? !press_alt ? superkey=press_superkey;
		!press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl=press_ctrl;
		!press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift=press_shift;
		!press_superkey ? !press_ctrl ? !press_shift ? press_alt ? alt=press_alt;
		!press_superkey ? !press_ctrl ? press_shift ? press_alt ? shift_alt=1;
		!press_superkey ? press_ctrl ? press_shift ? !press_alt ? shift_ctrl=1;
		press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift_superkey=1;
		press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl_superkey=1;
		press_superkey ? !press_ctrl ? !press_shift ? press_alt ? alt_superkey=1;
		
		mouseClick = mouseHold - lastCap;
		lastCap = mouseHold;
	);

	function get_zoom(dfile) local(dzoom s2_zoom_X s2_zoom_y) (
		gfx_getimgdim(dfile, d_bg_w, d_bg_h);
		s2_zoom_X = gfx_w / d_bg_w*2;
		s2_zoom_y = gfx_h / d_bg_h*2;
		bg_ratio=d_bg_w/d_bg_h;
		gfx_ratio=gfx_w/gfx_h;
		//if full ui, resize freely; if mcp ui, resize scaling only to width
		gfx_ext_flags == 1 && gfx_ratio>bg_ratio?(dzoom=s2_zoom_x):(dzoom = min(s2_zoom_x, s2_zoom_y));// * gfx_ext_retina;
		zoom_off == 1 && gfx_ext_flags == 0 ? dzoom = gfx_ext_retina;
		dzoom;
	);





	function Mouse_Sensivity () (
		S2_Mouse_Sensivity = 300;
		S2_Mouse_Finetune = 10;
	);

		Function HPF_Config (Hz) instance (CHLP_cx_hp cutoff_hp res_hp n_hp k CHLP_c1 CHLP_c2 CHLP_c3 CHLP_a0_hp CHLP_a1_hp CHLP_a2_hp CHLP_b1_hp CHLP_b2_hp) (
			CHLP_cx_hp = Hz*(3/4); N_hp = 5;
			cutoff_hp = 2*CHLP_cx_hp/srate;
			res_hp = 10^(0.05*(-0/n_hp+1.5));

			k = 0.55*res_hp*sin($pi*cutoff_hp);
			CHLP_c1 = 0.5*(1-k)/(1+k);
			CHLP_c2 = (0.5+CHLP_c1)*cos($pi*cutoff_hp);
			CHLP_c3 = (0.5+CHLP_c1+CHLP_c2)*0.25;

			CHLP_a0_hp = 2*CHLP_c3;
			CHLP_a1_hp = -4*CHLP_c3;
			CHLP_a2_hp = 2*CHLP_c3;
			CHLP_b1_hp = -2*CHLP_c2;
			CHLP_b2_hp = 2*CHLP_c1;
		);

		Function HPF_do(signal) instance (CHLP_cx_hp cutoff_hp res_hp n_hp k CHLP_c1 CHLP_c2 CHLP_c3 CHLP_a0_hp CHLP_a1_hp CHLP_a2_hp CHLP_b1_hp CHLP_b2_hp CHLP_hp_l_11 CHLP_hp_l_12 CHLP_hp_l_13 CHLP_hp_l_14 CHLP_hp_l_21 CHLP_hp_l_22 CHLP_hp_l_23 CHLP_hp_l_24 CHLP_hp_l_31 CHLP_hp_l_32 CHLP_hp_l_33 CHLP_hp_l_34 CHLP_hp_l_41 CHLP_hp_l_42 CHLP_hp_l_43 CHLP_hp_l_44 CHLP_hp_l_51 CHLP_hp_l_52 CHLP_hp_l_53 CHLP_hp_l_54 CHLP_hp_l_61 CHLP_hp_l_62 CHLP_hp_l_63 CHLP_hp_l_64 CHLP_out_hp_l CHLP_out_hp_l_1 CHLP_out_hp_l_2 CHLP_out_hp_l_3 CHLP_out_hp_l_4 CHLP_out_hp_l_5 CHLP_out_hp_l_6) (
CHLP_cx_hp > 7.5 ? ( //wenn mehr als 10Hz
n_hp > 0 ? (
CHLP_out_hp_l_1 = CHLP_a0_hp*signal+CHLP_a1_hp*CHLP_hp_l_11+CHLP_a2_hp*CHLP_hp_l_12-CHLP_b1_hp*CHLP_hp_l_13-CHLP_b2_hp*CHLP_hp_l_14;
CHLP_hp_l_12 = CHLP_hp_l_11;
CHLP_hp_l_11 = signal;
CHLP_hp_l_14 = CHLP_hp_l_13;
CHLP_hp_l_13 = CHLP_out_hp_l_1;
CHLP_out_hp_l = CHLP_out_hp_l_1;
n_hp > 1 ? (
CHLP_out_hp_l_2 = CHLP_a0_hp*CHLP_out_hp_l_1+CHLP_a1_hp*CHLP_hp_l_21+CHLP_a2_hp*CHLP_hp_l_22-CHLP_b1_hp*CHLP_hp_l_23-CHLP_b2_hp*CHLP_hp_l_24;
CHLP_hp_l_22 = CHLP_hp_l_21;
CHLP_hp_l_21 = CHLP_out_hp_l_1;
CHLP_hp_l_24 = CHLP_hp_l_23;
CHLP_hp_l_23 = CHLP_out_hp_l_2;
CHLP_out_hp_l = CHLP_out_hp_l_2;
);
n_hp > 2 ? (
CHLP_out_hp_l_3 = CHLP_a0_hp*CHLP_out_hp_l_2+CHLP_a1_hp*CHLP_hp_l_31+CHLP_a2_hp*CHLP_hp_l_32-CHLP_b1_hp*CHLP_hp_l_33-CHLP_b2_hp*CHLP_hp_l_34;
CHLP_hp_l_32 = CHLP_hp_l_31;
CHLP_hp_l_31 = CHLP_out_hp_l_2;
CHLP_hp_l_34 = CHLP_hp_l_33;
CHLP_hp_l_33 = CHLP_out_hp_l_3;
CHLP_out_hp_l = CHLP_out_hp_l_3;
);
n_hp > 3 ? (
CHLP_out_hp_l_4 = CHLP_a0_hp*CHLP_out_hp_l_3+CHLP_a1_hp*CHLP_hp_l_41+CHLP_a2_hp*CHLP_hp_l_42-CHLP_b1_hp*CHLP_hp_l_43-CHLP_b2_hp*CHLP_hp_l_44;
CHLP_hp_l_42 = CHLP_hp_l_41;
CHLP_hp_l_41 = CHLP_out_hp_l_3;
CHLP_hp_l_44 = CHLP_hp_l_43;
CHLP_hp_l_43 = CHLP_out_hp_l_4;
CHLP_out_hp_l = CHLP_out_hp_l_4;
);
n_hp > 4 ? (
CHLP_out_hp_l_5 = CHLP_a0_hp*CHLP_out_hp_l_4+CHLP_a1_hp*CHLP_hp_l_51+CHLP_a2_hp*CHLP_hp_l_52-CHLP_b1_hp*CHLP_hp_l_53-CHLP_b2_hp*CHLP_hp_l_54;
CHLP_hp_l_52 = CHLP_hp_l_51;
CHLP_hp_l_51 = CHLP_out_hp_l_4;
CHLP_hp_l_54 = CHLP_hp_l_53;
CHLP_hp_l_53 = CHLP_out_hp_l_5;
CHLP_out_hp_l = CHLP_out_hp_l_5;
);
n_hp > 5 ? (
CHLP_out_hp_l_6 = CHLP_a0_hp*CHLP_out_hp_l_5+CHLP_a1_hp*CHLP_hp_l_61+CHLP_a2_hp*CHLP_hp_l_62-CHLP_b1_hp*CHLP_hp_l_63-CHLP_b2_hp*CHLP_hp_l_64;
CHLP_hp_l_62 = CHLP_hp_l_61;
CHLP_hp_l_61 = CHLP_out_hp_l_5;
CHLP_hp_l_64 = CHLP_hp_l_63;
CHLP_hp_l_63 = CHLP_out_hp_l_6;
CHLP_out_hp_l = CHLP_out_hp_l_6;
);
);
CHLP_out_hp_l;
):(
CHLP_out_hp_l = signal;
CHLP_out_hp_l;
);
		);



 function v_meter_show() 
 instance (xIn yIn width height dB_range dB_Val dB_Val_Max)
 local (dB_clipped dB_Max_clipped)
 (
  db_clipped = min(0, this.dB_Val);
  db_Max_clipped = min(0, this.db_Val_Max);
 db_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom, this.yIn*zoom - db_clipped*(this.height*zoom/this.db_range), this.width *zoom,this.height*zoom- db_clipped*(this.height*zoom/this.db_range));
 db_max_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom, this.yIn*zoom - db_max_clipped*(this.height*zoom/this.db_range),this.width*zoom, min(1,2*zoom));
 );

 function v_gr_meter_show() 
 instance (xIn yIn width heihgt dB_range dB_Val dB_Val_Max dB_Val_Max_GR)
 local (dB_clipped dB_Max_clipped)
 (
  db_clipped = min(0, this.dB_Val);
  db_Max_clipped = min(0, this.db_Val_Max_GR);
	gfx_x = ceil(this.xIn*zoom); gfx_y = this.yIn*zoom;
 db_clipped >= -this.db_range ? (
			gfx_rectto(this.xIn*zoom+this.width *zoom ,this.yIn*zoom + this.height*zoom*0 - db_clipped*(this.height*zoom/this.db_range));
				):(
			Katie = 0;//gfx_rectto(this.xIn*zoom,this.yIn*zoom + this.height*zoom);
				);
 db_max_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom, this.yIn*zoom - db_max_clipped*(this.height*zoom/this.db_range), this.width*zoom, min(1,2*zoom));
 );

 function meter_show() 
 instance (xIn yIn width heihgt dB_range dB_Val dB_Val_Max)
 local (dB_clipped dB_Max_clipped)
 (
  db_clipped = min(0, this.dB_Val);
  db_Max_clipped = min(0, this.db_Val_Max);
 db_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom, this.yIn*zoom, this.width *zoom + db_clipped*(this.width*zoom/this.db_range),this.height*zoom);
 db_max_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom+this.width *zoom + db_max_clipped*(this.width*zoom/this.db_range), this.yIn*zoom, min(1,2*zoom),this.height*zoom);
 );
 


 function gr_meter_show() 
 instance (xIn yIn width heihgt dB_range dB_Val dB_Val_Max dB_Val_Max_GR)
 local (dB_clipped dB_Max_clipped)
 (
  db_clipped = min(0, this.dB_Val);
  db_Max_clipped = min(0, this.db_Val_Max_GR);
	gfx_x = ceil(this.xIn*zoom+ this.width*zoom); gfx_y = this.yIn*zoom;
 db_clipped >= -this.db_range ? (
			gfx_rectto(ceil(this.xIn*zoom+this.width *zoom + db_clipped*(this.width*zoom/this.db_range)),this.yIn*zoom + this.height*zoom);
				):(
			gfx_rectto(this.xIn*zoom,this.yIn*zoom + this.height*zoom);
				);
 db_max_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom+this.width *zoom + db_max_clipped*(this.width*zoom/this.db_range), this.yIn*zoom, min(1,2*zoom),this.height*zoom);
 );




 function meter_overlay ()
 instance (xIn yIn width heihgt dB_range dB_Val dB_Val_Max)
 local(loop_step)
 (
  loop_step = 0;
  loop(this.width * zoom,
    gfx_a = 1 - loop_step*2/(this.width * zoom);
   //gfx_rect(this.xIn*zoom+ loop_step, this.yIn*zoom, 1, this.height*zoom);
    gfx_line(this.xIn*zoom+ loop_step, this.yIn*zoom,this.xIn*zoom+ loop_step, this.yIn*zoom+this.height*zoom);
  loop_step +=0.5;
  );
 );
 
 function meter_config(xIn_ yIn_ width_ height_ db_range_ S2_meter_fallback_) 
 instance (xIn yIn width heihgt dB_range S2_meter_fallback)
 (
 this.xIn = xIn_;
 this.yIn = yIn_;
 this.width = width_;
 this.height = height_;
 this.db_range = dB_range_;
 this.S2_meter_fallback = S2_meter_fallback_;
 );



function db2ratio(d) ( 10^(d/20); );
function ratio2db(r) ( log(abs(r))*(20/log(10)); );

function feed_meter(in_spl) 
instance (U_Val dB_Val dB_Val_Max S2_meter_fallback)
(
    this.U_Val=abs(in_spl);
        ratio2db(this.U_Val) > this.dB_Val ? (
        this.dB_Val = ratio2db(this.U_Val);
    ):(
        this.dB_Val -= this.S2_meter_fallback/srate; // db pro sec
    );
    this.dB_Val_Max = max(this.dB_Val_Max,this.dB_Val);
	this.dB_Val_Max_GR = min(this.dB_Val_Max_GR,this.dB_Val);
);


function feed_meter_gr(in_spl) 
instance (U_Val dB_Val dB_Val_Max S2_meter_fallback)
(
    this.U_Val=abs(in_spl);
        ratio2db(this.U_Val) < this.dB_Val ? (
        this.dB_Val = ratio2db(this.U_Val);
    ):(
        this.dB_Val += this.S2_meter_fallback/srate; // db pro sec
    );
    this.dB_Val_Max = max(this.dB_Val_Max,this.dB_Val);
	this.dB_Val_Max_GR = min(this.dB_Val_Max_GR,this.dB_Val);
);


	function labelposition (S2_Labelpos, s2label_w, s2label_h) (
			        S2_xpos = this.xIn*zoom + (this.size*zoom/4) - (this.size*zoom/4)*(cos(-$pi*-((S2_labelpos-1)*0.7775 -1.1)/4));
      				s2_ypos = this.yIn*zoom + (this.size*zoom/4) - (this.size*zoom/4)*(sin(-$pi*-((S2_labelpos-1)*0.7775 -1.1)/4));
      				gfx_measurestr(" ", S2add_x, s2add_y);
      				S2_labelpos < 5 ? (gfx_x = s2_xpos - S2label_w - S2add_x; gfx_y = s2_ypos - s2label_h/2);
      				S2_labelpos == 5 ? (gfx_x = s2_xpos - S2label_w/2; gfx_y = s2_ypos - s2label_h);
     				S2_labelpos > 5 ? (gfx_x = s2_xpos + 1.5*S2add_x; gfx_y = s2_ypos - s2label_h/2);
				//gfx_x = s2_xpos; gfx_y = s2_ypos;
	);







	function group_parameters () (
		link_group ? (
			gmem[16*64 + 10 + link_group] == 1 ? (
					While_Playing = gmem[16*64 + 27 + link_group];
					While_Recording = gmem[16*64 + 27 + 16 + link_group];
					While_Stopped = gmem[16*64 + 27 + 32 + link_group];
      				slider_loop_temp = 1;
      				loop(S2_numbers_of_sliders,
        				sliders_old[slider_loop_temp] == slider(slider_loop_temp) ? (
          					gmem[(Link_Group-1)*64+ slider_loop_temp-1] != slider(slider_loop_temp) ? ( 
            						slider(slider_loop_temp) = sliders_old[slider_loop_temp] = gmem[(Link_Group-1)*64+ slider_loop_temp-1];
          					);
        				):(
          					gmem[(Link_Group-1)*64+ slider_loop_temp-1] = slider(slider_loop_temp);
          					sliders_old[slider_loop_temp] = slider(slider_loop_temp);
        				);
        			slider_loop_temp += 1;
      				);
      				slider_loop_temp = 1;
      				loop(S2_numbers_of_generics,
        				generics_old[slider_loop_temp] == group_generics[slider_loop_temp] ? (
          					gmem[16*64+27+48+slider_loop_temp+(Link_Group-1)*200] != group_generics[slider_loop_temp] ? ( 
            						group_generics[slider_loop_temp] = generics_old[slider_loop_temp] = gmem[16*64+27+48+slider_loop_temp+(Link_Group-1)*200];
          					);
        				):(
          					gmem[16*64+27+48+slider_loop_temp+(Link_Group-1)*200] = group_generics[slider_loop_temp];
          					generics_old[slider_loop_temp] = group_generics[slider_loop_temp];
        				);
        			slider_loop_temp += 1;
      				);
			):(link_group = 0;
			);

		);
	);


	function group_check_smpl () (
			S2_sample_on = 1;
			link_group ? (
      			slider_loop_temp_smpl = 1;
      			loop(S2_numbers_of_sliders,
        				gmem[(Link_Group-1)*64+ slider_loop_temp_smpl-1] != slider(slider_loop_temp_smpl) ? caller = 1;
        				slider_loop_temp_smpl += 1;
      			);
			slider_loop_temp_smpl = 1;
      			loop(S2_numbers_of_generics,
        				gmem[16*64+27+48+slider_loop_temp_smpl+(Link_Group-1)*200] != group_generics[slider_loop_temp_smpl] ? caller = 1;
        				slider_loop_temp_smpl += 1;
      			);
			gmem[16*64 + 27 + link_group] != While_Playing ? Caller = 1;
			gmem[16*64 + 27 + 16+link_group] != While_Recording ? Caller = 1;
			gmem[16*64 + 27 + 32+link_group] != While_Stopped ? Caller = 1;
			);
	);


	function group_check_gfx () (
      			slider_loop_temp_gfx = 1;
			link_group ? (
      			loop(S2_numbers_of_sliders,
        				gmem[(Link_Group-1)*64+ slider_loop_temp_gfx-1] != slider(slider_loop_temp_gfx) ? caller = 1;
        				slider_loop_temp_gfx += 1;
      			);
			slider_loop_temp_gfx = 1;
      			loop(S2_numbers_of_generics,
        				gmem[16*64+27+48+slider_loop_temp_gfx+(Link_Group-1)*200] != group_generics[slider_loop_temp_gfx] ? caller = 1;
        				slider_loop_temp_gfx += 1;
      			);
			gmem[16*64 + 27 + link_group] != While_Playing ? Caller = 1;
			gmem[16*64 + 27 + 16+link_group] != While_Recording ? Caller = 1;
			gmem[16*64 + 27 + 32+link_group] != While_Stopped ? Caller = 1;
			);
	);



	function processing_update() (
		link_group ? (
			gmem[16*64 + 27 + link_group] = While_Playing;
			gmem[16*64 + 27 + 16+link_group] = While_Recording;
			gmem[16*64 + 27 + 32+link_group] = While_Stopped;
		);
	);



	Function group_matching () local(tmp)  (
		Link_Group ? (
			gmem[16*64 + 10 + link_group] == 1 ? (
				tmp = 1;
				loop(s2_numbers_of_sliders,
		  			slider(tmp) != gmem[(Link_Group-1)*64+tmp-1] ? (slider(tmp) = gmem[(Link_Group-1)*64+tmp-1]; caller = 1);
					tmp +=1;
				);
					While_Playing = gmem[16*64 + 27 + link_group];
					While_Recording = gmem[16*64 + 27 + 16 + link_group];
					While_Stopped = gmem[16*64 + 27 + 32 + link_group];
					tmp = 1;
					loop(s2_numbers_of_generics,
		  				group_generics[tmp] != gmem[16*64+27+48+tmp+(Link_Group-1)*200] ? (group_generics[tmp] = gmem[16*64+27+48+tmp+(Link_Group-1)*200]; caller = 1);
					tmp +=1;
					);
			):(
				link_group = 0;
			);
		);
	);

	Function group_master_collision () local(tmp)  (
		Link_Group ? (
				tmp = 1;
				loop(s2_numbers_of_sliders,
		  			slider(tmp) != gmem[(Link_Group-1)*64+tmp-1] ? link_group_master = 0;
					tmp +=1;
				);
		);
	);

	Function group_update () local(tmp)  (
		Link_Group ? (
		gmem[16*64 + 10 + link_group] = 1; // Group ON
		gmem[16*64 + 27 + link_group] = While_Playing;
		gmem[16*64 + 27 + 16 + link_group] = While_Recording;
		gmem[16*64 + 27 + 32 + link_group] = While_Stopped;
		tmp = 1;
		loop(s2_numbers_of_sliders,
		  slider(tmp) != gmem[(Link_Group-1)*64+tmp-1] ? (gmem[(Link_Group-1)*64+tmp-1] = slider(tmp));
			tmp +=1;
		);
		tmp = 1;
		loop(s2_numbers_of_generics,
		  group_generics[tmp] != gmem[16*64+27+48+tmp+(Link_Group-1)*200] ? (gmem[16*64+27+48+tmp+(Link_Group-1)*200] = group_generics[tmp]);
			tmp +=1;
		);
		);
	);


     function playstates () (
	play_state == 0 ? (is_recording = 0; is_playing = 0; is_stopped = 1);     
	play_state == 1 ? (is_recording = 0; is_playing = 1; is_stopped = 0); 
	play_state == 2 ? (is_recording = 0; is_playing = 0; is_stopped = 1); 
	play_state == 5 ? (is_recording = 1; is_playing = 0; is_stopped = 0);
	play_state == 6 ? (is_recording = 0; is_playing = 0; is_stopped = 1);
	);


    function knoblabelposition (textw) (
    gfx_setfont(1,"Arial",12*zoom,'b');
    gfx_x = (this.xIn * zoom) + (this.size*zoom/4) - (textw / 2); gfx_y = (this.yIn * zoom) + (this.size*zoom / 2) + (5 * zoom);
    );

    function knobmeasureposition (textw, texth) (
    gfx_setfont(1,"Arial",12*zoom,'b');
    gfx_x = (this.xIn * zoom) + (this.size*zoom/4) - (textw / 2); gfx_y = (this.yIn * zoom) + (this.size*zoom / 2) - (texth/2);
    );
    






	function labelposition_scaled (S2_Labelpos, s2label_w, s2label_h) (
			        S2_xpos = this.xIn*zoom + this.scaling*(this.size*zoom/4) - this.scaling*(this.size*zoom/4)*(cos(-$pi*-((S2_labelpos-1)*0.7775 -1.1)/4));
      				s2_ypos = this.yIn*zoom + this.scaling*(this.size*zoom/4) - this.scaling*(this.size*zoom/4)*(sin(-$pi*-((S2_labelpos-1)*0.7775 -1.1)/4));
      				gfx_measurestr(" ", S2add_x, s2add_y);
      				S2_labelpos < 5 ? (gfx_x = s2_xpos - S2label_w - S2add_x; gfx_y = s2_ypos - s2label_h/2);
      				S2_labelpos == 5 ? (gfx_x = s2_xpos - S2label_w/2; gfx_y = s2_ypos - s2label_h);
     				S2_labelpos > 5 ? (gfx_x = s2_xpos + 1.5*S2add_x; gfx_y = s2_ypos - s2label_h/2);
				//gfx_x = s2_xpos; gfx_y = s2_ypos;
	);

    function knoblabelposition_scaled (textw) (
    gfx_setfont(1,"Arial",12*zoom,'b');
    gfx_x = (this.xIn * zoom) + this.scaling*(this.size*zoom/4) - (textw / 2); gfx_y = (this.yIn * zoom) + this.scaling*(this.size*zoom / 2) + (5 * zoom);
    );

    function knobmeasureposition_scaled (textw, texth) (
    gfx_setfont(1,"Arial",12*zoom,'b');
    gfx_x = (this.xIn * zoom) + this.scaling*(this.size*zoom/4) - (textw / 2); gfx_y = (this.yIn * zoom) + this.scaling*(this.size*zoom / 2) - (texth/2);
    );





    function readout () (
	    gfx_setfont(1,"Verdana");
    sprintf(#readout, "%.2f", slider(this.slider));
    gfx_x = this.xIn*zoom; gfx_y = this.yIn*zoom - gfx_texth - 2*zoom;
	gfx_y<0?gfx_y=0;
	gfx_x<0?gfx_x=0;
    gfx_measurestr(#readout, rdow, rdoh);
    gfx_r=gfx_b=gfx_g=0; gfx_a=0.4; gfx_rect(gfx_x+2*zoom, gfx_y, rdow+3*zoom, gfx_texth+2*zoom);
    gfx_r=gfx_g=gfx_b=1; gfx_a=0.7;
    gfx_x += 3*zoom;
    gfx_drawstr(#readout);
	gfx_a=1;
    );

	function Parameter_Boundaries () 
		instance (minVal maxVal slider)
		(
		katze=0;
			slider(this.slider) = min(max(slider(this.slider), this.minval), this.maxval);
		);






	function switch_config  (xIn_ yIn_)
        instance        (xIn yIn)
                        (
                        xIn = xIn_;
                        yIn = yIn_;
                        );



      function knob_rev()
                   (
						gfx_x=this.xIn*zoom; gfx_y=this.yIn*zoom;
						weg = abs(minVal - maxVal);
						kframe = (this.maxVal - slider(this.slider)) * (this.frames-1) / (this.maxVal - this.minVal);
						scry = this.size * floor(kframe);
						//gfx_blit(this.file,this.scaling,0,0,scry,this.size,this.size);
						gfx_blit(this.file, this.scaling * zoom / 2, 0, 0, scry, this.size,this.size);
                    );




	function Color_button (color_) local (on) (
				slider(this.slider) > 0 ? (on = 1):(on=0);
      				gfx_x=this.xIn*zoom; gfx_y=this.yIn*zoom;
      				gfx_blit(button, zoom/2, 0, 0, on*70, 70, 70);
      				gfx_x += 28 * zoom; gfx_y += 2*zoom;
      				gfx_blit(color_, zoom/4, 0, 0, on * 128, 128, 128);
    	);

	function button3 () local (on) (
				slider(this.slider) > 0 ? (on = 1):(on=0);
      				gfx_x=this.xIn*zoom; gfx_y=this.yIn*zoom;
      				gfx_blit(button, zoom/2, 0, 0, on*70, 70, 70);
      				gfx_x += 28 * zoom; gfx_y += 2*zoom;
      				slider(this.slider) == 0 ? gfx_blit(rled, zoom/4, 0, 0, on * 128, 128, 128);
				slider(this.slider) == 1 ? gfx_blit(oled, zoom/4, 0, 0, on * 128, 128, 128);
				slider(this.slider) == 2 ? gfx_blit(rled, zoom/4, 0, 0, on * 128, 128, 128);
    	);





	function black() (gfx_r=gfx_g=gfx_b=0);
	function white() (gfx_r=gfx_g=gfx_b=1);
    	function lightgrey() (gfx_r=gfx_g=gfx_b=0.65);
    	function lakeblue() (gfx_r=13/255;gfx_g=189/255;gfx_b=208/255);  
    	function orange () (gfx_r = 1; gfx_g=0.5; gfx_b=0;);
	function red () (gfx_r = 1; gfx_g=0; gfx_b=0;);
	function green () (gfx_r = 0; gfx_g=1; gfx_b=0;);
	function blue () (gfx_r = 0; gfx_g=0; gfx_b=1);

	function xy(x y) (gfx_x = x; gfx_y = y);
	function rgb(r, g, b) (gfx_r = r / 255; gfx_g = g / 255; gfx_b = b / 255);

          function rgb_palette (S2_Palette) (
                  S2_Palette == 8 ? rgb(255,255,2): // Yellow
                  S2_Palette == 2 ? rgb(153,255,51): // lime
                  S2_Palette == 3 ? rgb(102,255,255): //cyan
                  S2_Palette == 4 ? rgb(255,204,1): // orange
                  S2_Palette == 5 ? rgb(255,0,255): // pink
                  S2_Palette == 6 ? rgb(255,51,1): // red
                  S2_Palette == 7 ? rgb(203,255,255): //babyblue
                  S2_Palette == 15 ? rgb(204,102,255): // purple
                  S2_Palette == 9 ? rgb(255,153,204): // rosa
                  S2_Palette == 10 ? rgb(0,204,0): // green
                  S2_Palette == 11 ? rgb(255,204,204): // beige
                  S2_Palette == 12 ? rgb(51,153,255): // blue
                  S2_Palette == 13 ? rgb(102,255,204): // turkies
                  S2_Palette == 14 ? rgb(255,255,153): // light Yellow
                  S2_Palette == 1 ? rgb(255,153,102): // rost
                  S2_Palette == 16 ? rgb(204,204,0); // Olive
          );


        function k_collision  ()
                          (
                           mouse_x > this.xIn*zoom && mouse_x < this.xIn*zoom + 0.5*this.size*this.scaling*zoom && mouse_y > this.yIn*zoom && mouse_y < this.yIn*zoom + 0.5*this.kheight*this.scaling*zoom
                          );
      
	function g_collision  (g_xin g_yin g_w g_h)
                          (
                           mouse_x > g_xin && mouse_x < g_xin + g_w && mouse_y > g_yin && mouse_y < g_yin + g_h
                          );




	function number_input_show () (
		gfx_r=gfx_g=gfx_b=0;
		gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
		gfx_r=0;gfx_g=1;gfx_b=0;
		gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
		gfx_r=gfx_g=gfx_b=0.7;
		gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
		gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
		gfx_drawnumber(number_input_use,NI_komma);


  			mouseclick && !shift_alt ? 
			(
				g_collision(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5) ?
				(
					valid = 0;
					number_input_use >= number_input_min && number_input_use <= number_input_max ? valid = 1;
					valid ? (
					slider(number_input_slider) = number_input_use;
					caller = 1;
					):(
					number_input_invalid = 90;
					);
					Number_input = 0;
					number_input_raw = 0;
					number_input_use = 0;
					NI_komma = 0;
					in_key = 0;
					//number_input_x = 0;
					//number_input_y=0;
				):(
					Number_input = 0;
					number_input_raw = 0;
					number_input_use = 0;
					NI_komma = 0;
					in_key = 0;
					number_input_x = 0;
					number_input_y=0;
				);
			);

			in_key=gfx_getchar();

			in_key ? Aaa = in_key;
  			in_key == 8 ? (
  			number_input_raw = floor(number_input_raw/10);
  			NI_komma = max(0,komma-1);
  			NI_komma == 1 ? NI_komma = 0;
  			);

			in_key == 45 ? number_input_sign*=-1;

			in_key == 46 ? NI_komma = 1;
			in_key > 47 ? (
			in_key < 58 ? (
    			number_input_raw = (number_input_raw*10) + (in_key-48);
    			NI_komma ? NI_komma += 1;
			);
			);

			NI_komma ? (number_input_use = number_input_raw / (10^(NI_komma-1))):(number_input_use = number_input_raw);
			number_input_use *= number_input_sign;

		);


	function number_input_start () (
		number_input_x = this.xin;
		number_input_y = this.yin;
     		number_input = 1;
		number_input_slider = this.slider;
		number_input_min = this.minval;
		number_input_max = this.maxval;
		number_input_sign=1;
	);


      function dragStart ()
        instance          (dragging yOld default slider valold)
                          (
			   !shift_alt ? (
                           !ctrl ? (
                           yOld = mouse_y;xOld = mouse_x;link_yOld = mouse_y;
                           dragging = 1;
                           valold = slider(slider); 
				gmem[16*64 + 2] = 0;
                          ) : 
                           (slider(slider) = default;caller = 1;
			    gmem[(Link_Group-1)*64+slider-1] = slider(slider);
                            valold = slider(slider);
                            slider_automate(slider(slider));
                          );
			  ):(this.number_input_start());
			  superkey ? (gmem[16*64 + 3] = 1);
			  shift_superkey ? (gmem[16*64 + 3] = 1);
				ctrl_superkey ? (
					gmem[16*64 + 1] = slider;
					gmem[16*64 + 3] = 2;
					gmem[16*64 + 2] = default;
					slider(slider) = default;
			    		gmem[(Link_Group-1)*64+slider-1] = slider(slider);
                            		valold = slider(slider);
                            		slider_automate(slider(slider));
				);
				gen_dragging = 1;
				knob_dragging = 1;
			 );
      
      function v_dragStart ()
        instance          (v_dragging yOld xOld default slider valold)
                          (
			!shift_alt ? (
                           !ctrl ? (
                           yOld = mouse_y;xOld = mouse_x;link_yOld = mouse_y;
                           v_dragging = 1;
                           valold = slider(slider);
				gmem[16*64 + 2] = 0;
                          ) : 
                           (slider(slider) = default;caller = 1;
			    gmem[(Link_Group-1)*64+slider-1] = slider(slider);
                            valold = slider(slider);
                            slider_automate(slider(slider));
                          );
			  );
			  superkey ? (gmem[16*64 + 3] = 1);
			  shift_superkey ? (gmem[16*64 + 3] = 1);
				ctrl_superkey ? (
					gmem[16*64 + 1] = slider;
					gmem[16*64 + 3] = 2;
					gmem[16*64 + 2] = default;
					slider(slider) = default;
			    		gmem[(Link_Group-1)*64+slider-1] = slider(slider);
                            		valold = slider(slider);
                            		slider_automate(slider(slider));
				);
				gen_dragging = 1;
			);

      function h_dragStart ()
        instance          (h_dragging yOld xOld default slider valold)
                          (
			!shift_alt ? (
                           !ctrl ? (
                           yOld = mouse_y;xOld = mouse_x;link_yOld = mouse_y;
                           h_dragging = 1;
                           valold = slider(slider);
				gmem[16*64 + 2] = 0;
                          ) : 
                           (slider(slider) = default;caller = 1;
			    gmem[(Link_Group-1)*64+slider-1] = slider(slider);
                            valold = slider(slider);
                            slider_automate(slider(slider));
				gmem[16*64 + 1] = slider;
				_global.linked_slider = slider;
				_global.linked_reset = 1;
				_global.linked_force = default;
                          );
			  );
			  superkey ? (gmem[16*64 + 3] = 1);
			  shift_superkey ? (gmem[16*64 + 3] = 1);
				ctrl_superkey ? (
					gmem[16*64 + 1] = slider;
					gmem[16*64 + 3] = 2;
					gmem[16*64 + 2] = default;
					slider(slider) = default;
			    		gmem[(Link_Group-1)*64+slider-1] = slider(slider);
                            		valold = slider(slider);
                            		slider_automate(slider(slider));
				);
				gen_draggingg = 1;
			);

	function quicklink_button () instance(slider)
			(
				superkey ? (
					gmem[16*64 + 1] = slider;
					gmem[16*64 + 3] = 2;
					gmem[16*64 + 2] = slider(slider);
				);
			);


      function dragStop()
        instance        (dragging h_dragging v_dragging val valOld)
                        (
                         dragging = 0;
			 h_dragging = 0;
			 v_dragging = 0;
                         valOld = val;
				This.val = slider(slider);
			gmem[16*64 + 2] = 0;
			gmem[16*64 + 3] = 0;
			gen_dragging = 0;
			knob_dragging = 0;
                        );
      
      function potDragDeprecated()
            local      (val nachkomma)
              instance   (valOld minVal maxVal yOld step slider xIn yIn)
                       (
                        mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*gfx_ext_retina);
                        Shift ? mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*S2_Mouse_Finetune*gfx_ext_retina);
			Shift_superkey ? mstep = (this.maxval - this.minval)/(2000*gfx_ext_retina);
			val = valOld + (yOld - mouse_y) * mstep;
                        val = min(max(val, minVal), maxVal);
                        slider(slider) = val;
                        slider_automate(slider(slider));
                        gmem[16*64 + 1] = slider;
			gmem[16*64 + 2] = (yOld - mouse_y) * mstep;
                       );

	function closeststep(val) local (resultstep remainder val steps) (
		steps= this.step;
		steps==0?(resultstep=val):(
			remainder = val - floor((val/steps))*steps;
			remainder < (steps / 2) ? (
				resultstep = val - remainder;
			):(
				resultstep = val + (steps - remainder);
			);
			resultstep <= this.minVal ? resultstep=this.minVal;
			resultstep >= this.maxVal ? resultstep=this.maxVal;
		);
		resultstep;
	);
      function potDrag()
            local      (val nachkomma)
              instance   (valOld minVal maxVal yOld step slider xIn yIn)
                       (
                        mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*gfx_ext_retina);
                        Shift ? mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*S2_Mouse_Finetune*gfx_ext_retina);
			Shift_superkey ? mstep = (this.maxval - this.minval)/(2000*gfx_ext_retina);
			val = valOld + (yOld - mouse_y) * mstep;
                        val = min(max(val, minVal), maxVal);
                        slider(slider) = this.closeststep(val);
                        slider_automate(slider(slider));
                        gmem[16*64 + 1] = slider;
			gmem[16*64 + 2] = (yOld - mouse_y) * mstep;
                       );

      function potDrag_REV()
            local      (val nachkomma)
              instance   (valOld minVal maxVal yOld step slider xIn yIn)
                       (
                        mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*gfx_ext_retina);
                        Shift ? mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*S2_Mouse_Finetune*gfx_ext_retina);
			Shift_superkey ? mstep = (this.maxval - this.minval)/(2000*gfx_ext_retina);
			val = valOld - (yOld - mouse_y) * mstep;
                        val = min(max(val, minVal), maxVal);
                        //slider(slider) = val;
                        //slider_automate(slider(slider));
                        slider(slider) = this.closeststep(val);
                        slider_automate(slider(slider));
                        gmem[16*64 + 1] = slider;
			gmem[16*64 + 2] = -(yOld - mouse_y) * mstep;
                       );

      function potDrag_integer()
            local      (val nachkomma valid)
              instance   (valOld minVal maxVal yOld step slider xIn yIn)
                       (
                        mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*gfx_ext_retina);
                        Shift ? mstep = (this.maxval - this.minval)/(S2_Mouse_Sensivity*S2_Mouse_Finetune*gfx_ext_retina);
			Shift_superkey ? mstep = (this.maxval - this.minval)/(2000*gfx_ext_retina);
			val = valOld + (yOld - mouse_y) * mstep;
			abs(slider(slider) - val) >= 0.5 ? (val = floor(val+0.5); valid = 1):(valid=0);
                        val = min(max(val, minVal), maxVal);
                        valid != 0 ? slider(slider) = val;
                        slider_automate(slider(slider));
                        gmem[16*64 + 1] = slider;
			gmem[16*64 + 2] = floor((yOld - mouse_y) * mstep + 0.5);
                       );


      function v_potDrag(pixels)
            local      (val nachkomma)
              instance   (valOld minVal maxVal yOld step slider xIn yIn)
                       (
                         mstep = (this.maxval - this.minval)/(pixels);
                         Shift ? mstep = (this.maxval - this.minval)/(S2_Mouse_Finetune*pixels);
                         Shift_superkey ? mstep = (this.maxval - this.minval)/(10*pixels);
                        val = valOld + (yOld - mouse_y) * mstep;
                        val = min(max(val, minVal), maxVal);
                        slider(slider) = val;
                        slider_automate(slider(slider));
			gmem[16*64 + 1] = slider;
			gmem[16*64 + 2] = (yOld - mouse_y) * mstep;
                       );

      function h_potDrag(pixels)
            local      (val nachkomma)
              instance   (valOld minVal maxVal yOld xOld step slider xIn yIn)
                       (

                         mstep = (this.maxval - this.minval)/(pixels);
                         Shift ? mstep = (this.maxval - this.minval)/(10*pixels);
                         Shift_superkey ? mstep = (this.maxval - this.minval)/(S2_Mouse_Finetune*pixels);
                        val = valOld - (xOld - mouse_x) * mstep;
                        val = min(max(val, minVal), maxVal);
                        slider(slider) = val;
                        slider_automate(slider(slider));
			gmem[16*64 + 1] = slider;
			gmem[16*64 + 2] = -(xOld - mouse_x) * mstep;
	              );



	function input_handling() (
		number_input ? number_input_show();
		//OEQ_NI == 1 ? number_input
		number_input_invalid = max(0,number_input_invalid-1);
		number_input_invalid ? ( 
			gfx_r=gfx_g=gfx_b=0;
			gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
			gfx_r=0;gfx_g=1;gfx_b=0;
			gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
			red();
			gfx_rect(zoom*number_input_x + gfx_texth+5,zoom*number_input_y, 200*zoom - (gfx_texth+5), gfx_texth+5);
			gfx_r=gfx_g=gfx_b=0.7;
			gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
			gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
			white();
			gfx_drawstr("NO VALID INPUT!");
		);
	);

		      function b_collision  ()
                          (
                	           //mouse_x > this.xIn*zoom && mouse_x < this.xIn*zoom + 35 * zoom && mouse_y > this.yIn*zoom + 8 * zoom && mouse_y < this.yIn*zoom + 28 * zoom
							   gfx_getimgdim(this.file, d_btn_w, d_btn_h);
							   this.dist == 0 ? (d_btn_w=d_btn_w/2):this.dist == 1 ? (d_btn_h=d_btn_h/2);
						       d_btn_w = d_btn_w * this.scaling/2;
							   d_btn_h = d_btn_h * this.scaling/2;
                	           mouse_x > this.xIn*zoom && mouse_x < this.xIn*zoom + d_btn_w * zoom && mouse_y > this.yIn*zoom && mouse_y < this.yIn*zoom + d_btn_h * zoom
                          );
function button_toggle()(
			!Number_input ? (
				mouseClick == 1 ? (
					this.b_collision() ? (
						slider(this.slider)==this.onval ? (
							slider(this.slider) = this.offval ;
							slider_automate(slider(this.slider));
							this.quicklink_button();caller = 1;
						):(
							slider(this.slider) = this.onval;
							slider_automate(slider(this.slider));
							this.quicklink_button();caller = 1;
						);
					);
				); 
			);
);  
function button_config  (slider_ dist_ off_val on_val xIn_ yIn_ scaling_ file_ handle_mode) // // autohandle=1 toggle first and second value; autohandle=0 write your own code
	instance        (xIn yIn slider file dist scaling onval offval size kheight)
	(
		xIn = xIn_;
		yIn = yIn_;
		slider = slider_;
		file = file_;
		dist = dist_;
		scaling = scaling_;
		offval=off_val;
		onval=on_val;

		gfx_getimgdim(this.file, d_btn_w, d_btn_h);
		gfx_x=this.xIn*zoom; gfx_y=this.yIn*zoom;
		this.dist == 0 ? ( // horizontal
			size=d_btn_w/2;
			kheight=d_btn_h;
			slider(this.slider) != on_val ? (
				gfx_blit(this.file, ((zoom/2)*this.scaling), 0, 0, 0,size,d_btn_h);
			):(
				gfx_blit(this.file, ((zoom/2)*this.scaling), 0, size, 0,size,d_btn_h);
			);
		):this.dist == 1 ? ( // vertical
			size=d_btn_w;
			kheight=d_btn_h/2;
			slider(this.slider) != on_val ? (
				gfx_blit(this.file, ((zoom/2)*this.scaling), 0, 0, 0,d_btn_w,kheight);
			):(
				gfx_blit(this.file, ((zoom/2)*this.scaling), 0, 0, kheight,d_btn_w,kheight);
			);
		);

		handle_mode == 1 ? ( // if auto toggling is enabled
			this.button_toggle()
		);		
	);

	function potWheel()
        local         (val)
        instance      (valOld minVal maxVal step)
                      (
                       valOld=slider(this.slider);
		       mstep = (this.maxval - this.minval)/200;
                       val = valOld + (mouse_wheel/36)*mstep;
                       val = min(max(val, minVal), maxVal);
		       slider(this.slider) = val;
                       mouse_wheel=0;
                        );


	function potWheel_rev()
        local         (val)
        instance      (valOld minVal maxVal step)
                      (
                       valOld=slider(this.slider);
		       mstep = (this.maxval - this.minval)/200;
                       val = valOld - (mouse_wheel/36)*mstep;
                       val = min(max(val, minVal), maxVal);
		       slider(this.slider) = val;
                       mouse_wheel=0;
                        );
						
function Parameter_config  (slider_ default_ minVal_ maxVal_ step_ xIn_ yIn_ frames_ scaling_ file_ d_autohandle d_isrev) // autohandle=default mouse handling; autohandle=0 write your own code
	instance        (default minVal maxVal slider xIn yIn size frames scaling file step kheight)
	(
		default = default_;
		minVal = minVal_;
		maxVal = maxVal_;
		slider = slider_;
		//slider(slider) = default; Caller = 1;
		xIn = xIn_;
		yIn = yIn_;
		gfx_getimgdim(file_, d_png_w, d_png_h);
		frames_ == 0 ? (frames_ = d_png_h / d_png_w); // if frames = 0 then calculate how many frames the knob stack has
		size= d_png_w;
		frames = frames_;
		scaling = scaling_;
		file = file_;
		step=step_;
		kheight=d_png_h/frames;
		
		d_autohandle==1?(
			// handling
			gfx_x=this.xIn*zoom; gfx_y=this.yIn*zoom;
			weg = abs(minVal - maxVal);
			d_isrev==0 || d_isrev==2?(
				kframe = (slider(this.slider) - this.minVal) * (this.frames-1) / (this.maxVal - this.minVal);
			):d_isrev==1 || d_isrev==3?(
				kframe = (this.maxVal - slider(this.slider)) * (this.frames-1) / (this.maxVal - this.minVal);
			);
			//scry = this.size * floor(kframe);

			scry =  this.kheight* floor(kframe);
			//gfx_blit(this.file,this.scaling,0,0,scry,this.size,this.size);
			gfx_blit(this.file, this.scaling * zoom / 2, 0, 0, scry, this.size,this.kheight);
			
			!Number_input ?(  // if not default handling
				mouseClick == 1 ? (
					this.k_collision() ? (this.dragstart());
				); 
				mouseclick == -1 ? (  // stop knobs dragging
					this.dragstop();
				);
				d_isrev==0 || d_isrev==3?(
					mouse_wheel ? (  // handle wheel
						this.k_collision() ? this.potwheel();
						
						caller = 1;
					);
					gfx_a=1;  // handle drag
					this.dragging ? (this.potdrag();this.readout();caller = 1;);
				):d_isrev==1 || d_isrev==2?(
					mouse_wheel ? (  // handle wheel
						this.k_collision() ? this.potwheel_rev();
						
						caller = 1;
					);
					gfx_a=1;  // handle drag
					this.dragging ? (this.potdrag_rev();this.readout();caller = 1;);
				);

			);
			input_handling();
		);
);

/*
Text
center below frame
-distance
-text
-scale
Helvetica
*/

// d_string and d_font are strings ("string"), d_fontflags are multibyte characters ('multibyte'), not the difference between "" and ''
function attached_label(d_string d_yoffset d_font d_fontsize d_fontflags) local(d_fontflags d_font d_x_offset d_fontwidth d_fontheight d_string d_fontsize save_gfx_x save_gfx_y d_yoffset)(
	save_gfx_x=gfx_x; // just to prevent conflict with functions in future versions
	save_gfx_y=gfx_y;
	gfx_setfont(1,d_font, this.scaling*d_fontsize*zoom/2, d_fontflags);
	gfx_measurestr(d_string,d_fontwidth,d_fontheight);

	d_x_offset=((this.scaling*this.size)-d_fontwidth)/2;
	//gfx_x=0;//this.scaling*zoom*(this.xIn*zoom)+d_x_offset);
	gfx_x=(zoom*this.xIn)+ (((zoom*this.scaling*this.size/2)-d_fontwidth)/2) ;
	gfx_y=zoom*( this.yIn+ ( this.scaling* (d_yoffset+ (this.kheight/2) ) ) );
	//gfx_r=gfx_g=gfx_b=0.9;
	gfx_drawstr(d_string);

	gfx_x=save_gfx_x; // just to prevent conflict with functions in future versions
	gfx_y=save_gfx_y;
);

function Parameter_configEQT  (slider_ default_ minVal_ maxVal_ step_ xIn_ yIn_ frames_ scaling_ file_ d_autohandle d_isrev) // autohandle=default mouse handling; autohandle=0 write your own code
	instance        (default minVal maxVal slider xIn yIn size frames scaling file step)
	(
		default = default_;
		minVal = minVal_;
		maxVal = maxVal_;
		slider = slider_;
		//slider(slider) = default; Caller = 1;
		xIn = xIn_;
		yIn = yIn_;
		gfx_getimgdim(file_, d_png_w, d_png_h);
		frames_ == 0 ? (frames_ = d_png_h / d_png_w); // if frames = 0 then calculate how many frames the knob stack has
		size= d_png_w;
		frames = frames_;
		scaling = scaling_;
		file = file_;
		step=step_;

		// handling
                gfx_x=this.xIn*zoom; gfx_y=this.yIn*zoom;
                weg = abs(minVal - maxVal);
                //floor(slider1+0.1)
                 kframe = (floor(slider(this.slider)+0.1) - this.minVal) * (this.frames-1) / (this.maxVal - this.minVal);
                 scry = this.size * floor(kframe);
                 //gfx_blit(this.file,this.scaling,0,0,scry,this.size,this.size);
				gfx_blit(this.file, this.scaling * zoom / 2, 0, 0, scry, this.size,this.size);

		d_autohandle==1?(
			!Number_input ?(  // if not default handling
				mouseClick == 1 ? (
					this.k_collision() ? (this.dragstart());
				); 
				mouseclick == -1 ? (  // stop knobs dragging
					this.dragstop();
				);
				d_isrev==0?(
					mouse_wheel ? (  // handle wheel
						this.k_collision() ? this.potwheel();
						
						caller = 1;
					);
					gfx_a=1;  // handle drag
					this.dragging ? (this.potdrag();this.readout();caller = 1;);
				):d_isrev==1?(
					mouse_wheel ? (  // handle wheel
						this.k_collision() ? this.potwheel_rev();
						
						caller = 1;
					);
					gfx_a=1;  // handle drag
					this.dragging ? (this.potdrag_rev();this.readout();caller = 1;);
				);

			);
			input_handling();
		);
);

function set_background(d_file)( // only one argument, unfilled background is dark grey
	gfx_r=gfx_g=gfx_b=0.1;

    zoom = get_zoom(d_file); // set zoom scaling based on (file)s image dimentions
    gfx_rect(0,0,gfx_w,gfx_h); //background
    gfx_x = 0; gfx_y = 0; gfx_a = 1;
    gfx_blit(d_file,0.5*zoom,0); // set background image  png/scale/rotation
);

function set_background(d_file,red, green, blue) local(red green blue)( // rgb arguments, unfilled background is colored
	gfx_r=red;gfx_g=green;gfx_b=blue;
    zoom = get_zoom(d_file); // set zoom scaling based on (file)s image dimentions
    gfx_rect(0,0,gfx_w,gfx_h); //background
    gfx_x = 0; gfx_y = 0; gfx_a = 1;
    gfx_blit(d_file,0.5*zoom,0); // set background image  png/scale/rotation
);

/* background functions testing
function set_background(d_file,brightness) local(brightness)( // brightness argument, unfilled background is black-white 0-1; <0 = autodetect color
    zoom = get_zoom(d_file); // set zoom scaling based on (file)s image dimentions
	brightness >= 0 ? (
		gfx_r=gfx_g=gfx_b=brightness;
	):(
		gfx_getimgdim(d_file, d_bg_w, d_bg_h);
		gfx_w > (d_bg_w*zoom)? (
			gfx_x=d_bg_w-10*zoom; gfx_y=d_bg_h/2*zoom; // if ui is wider, use the rightmost pixels for reference
		):(
			gfx_y=d_bg_h-10*zoom; gfx_x=d_bg_w/2*zoom; // if ui is taller, use bottom pixels for reference
		);
		gfx_getpixel(redd,greend,blued);
		gfx_x=0; gfx_y=0; // reset
		gfx_r=redd;gfx_g=greend;gfx_b=blued; // set bg color
	);
    gfx_rect(0,0,gfx_w,gfx_h); //background
    gfx_x = 0; gfx_y = 0; gfx_a = 1;
    gfx_blit(d_file,0.5*zoom,0); // set background image  png/scale/rotation
);


*/

function setup_dmenu(setup_menu_name, setup_menu_version, setup_menu_graphics, dmenu_zoom)local(setup_menu_name, setup_menu_version, setup_menu_graphics)(
 dmenu_zoom=dmenu_zoom*zoom;
  ////////////////////////////////////////// MENU MENU MENU ////////////////////////////////////////////////
  last_clicked_item = -1;
  Helpshow ? mouse_cap ? (helpshow = 0;last_clicked_item = -1);
  menu_x = 4; menu_y =1;
 
 gfx_x = menu_x * dmenu_zoom; gfx_y = menu_y * dmenu_zoom; gfx_a=0.5;
 //gfx_blit(menu,dmenu_zoom/2,0);
 gfx_r=gfx_g=gfx_b=0.4; //red();
 gfx_roundrect(menu_x * dmenu_zoom, (menu_y + 5) * dmenu_zoom, 20*dmenu_zoom, 20*dmenu_zoom, 0, 1);
 gfx_line((menu_x+3)*dmenu_zoom, (menu_y + 11)*dmenu_zoom, (menu_x+17)*dmenu_zoom, (menu_y + 11)*dmenu_zoom);
 gfx_line((menu_x+3)*dmenu_zoom, (menu_y + 15)*dmenu_zoom, (menu_x+17)*dmenu_zoom, (menu_y + 15)*dmenu_zoom);
 gfx_line((menu_x+3)*dmenu_zoom, (menu_y + 19)*dmenu_zoom, (menu_x+17)*dmenu_zoom, (menu_y + 19)*dmenu_zoom);
 
 /*
 gfx_setfont(1,"Arial",22*dmenu_zoom,'b');
 gfx_r=gfx_g=gfx_b=0.6; gfx_x = menu_x * dmenu_zoom + 30*dmenu_zoom;gfx_y += 2*dmenu_zoom;
 gfx_drawstr(setup_menu_name); 

 gfx_setfont(1,"Arial",22*dmenu_zoom,'b');
 gfx_drawstr(" ");
 */
 gfx_x = menu_x+22 * dmenu_zoom; gfx_y += 2*dmenu_zoom;
 gfx_setfont(1,"Arial",22*dmenu_zoom,'b');
 
 
 
 link_group ? (
   rgb_palette(Link_group);// gfx_a = 0.7;
   gfx_drawstr("JOINS GROUP "); gfx_drawstr(sprintf(#,"%i", link_group));
 );
 gfx_a = 1;
 gfx_setfont(1,"Arial",12*dmenu_zoom,'b');
 
  mouseClick ? (
   g_collision(menu_x*dmenu_zoom, (menu_y+5) * dmenu_zoom, 20*dmenu_zoom, 20*dmenu_zoom) ? (
    gfx_x = menu_x*dmenu_zoom;
    gfx_y = (menu_y+20)*dmenu_zoom;
     
      #item2 =">Processing|";#allitems = #item2;
     while_playing == 1 ? (#item2 = "!On Playback|"):(#item2 = "On Playback|");#allitems += #item2;
     while_recording == 1 ? (#item2 = "!On Recording|"):(#item2 = "On Recording|");#allitems += #item2;
     while_stopped == 1 ? (#item2 = "<!On Stop|>Groups|"):(#item2 = "<On Stop|>Groups|");#allitems += #item2;
 
     mnu_grp_loop = 1;
     loop(16,
 
       mnu_grp_loop == 16 ? #item2 += "<";
       gmem[16*64 + 10 + mnu_grp_loop] == 1 ? ( //Gruppe schon an ?
         mnu_grp_loop == Link_Group ? ( //ist selbst in der gruppe
                 #item2 = "!Joins Group ";
         ):(
             #item2 = "Add to Group ";
         );
       ):(
         #item2 = "Start Group ";
       );
     mnu_grp_loop == 1 ? #item2 += "01";
     mnu_grp_loop == 2 ? #item2 += "02";
     mnu_grp_loop == 3 ? #item2 += "03";
     mnu_grp_loop == 4 ? #item2 += "04";
     mnu_grp_loop == 5 ? #item2 += "05";
     mnu_grp_loop == 6 ? #item2 += "06";
     mnu_grp_loop == 7 ? #item2 += "07";
     mnu_grp_loop == 8 ? #item2 += "08";
     mnu_grp_loop == 9 ? #item2 += "09";
     mnu_grp_loop == 10 ? #item2 += "10";
     mnu_grp_loop == 11 ? #item2 += "11";
     mnu_grp_loop == 12 ? #item2 += "12";
     mnu_grp_loop == 13 ? #item2 += "13";
     mnu_grp_loop == 14 ? #item2 += "14";
     mnu_grp_loop == 15 ? #item2 += "15";
     mnu_grp_loop == 16 ? #item2 += "16";
     
     #item2 += "|";
     #allitems += #item2; //sprintf(#temp, '%f',3); 
     mnu_grp_loop += 1;
     );
     
     link_group ? (#allitems += "|<Delete Group ";#allitems += sprintf(#, "%d", link_group);#allitems += "|"):#allitems += "|<#Delete Group|";
 
     //#allitems += "<#MENU|";
    #allitems += ">Scaling|";
    zoom_off == 0 ? (#item2 = "!Automatic Scaling|"):(#item2 = "Automatic scaling|");#allitems += #item2;
    zoom_off == 1 ? (#item2 = "<!No scaling|"):(#item2 = "<No scaling|");#allitems += #item2;
    
 
    
    #allitems += "|Show Info/Help";
    last_clicked_item = gfx_showmenu(#allitems);
  );
  );
 
 
 
 
  
  last_clicked_item == 1 ? (while_playing == 0 ? (while_playing = 1):(while_playing = 0);caller=1;processing_update());
  last_clicked_item == 2 ? (while_recording == 0 ? (while_recording = 1):(while_recording = 0);caller=1;processing_update());
  last_clicked_item == 3 ? (while_stopped == 0 ? (while_stopped = 1):(while_stopped = 0);caller=1;processing_update());
 
   cgroup = last_clicked_item - 3;
  last_clicked_item > 3 && last_clicked_item < 20 ? (
     Link_Group != cgroup ? ( //eigene Linkgruppe NICHT angeklickt
         gmem[16*64 + 10 + cgroup] == 0 ? ( // Gruppe noch frei
             //gmem[16*64 + 10 + cgroup] = 1; Link_Group = cgroup; gmem[16*64 +27 + cgruop] = 1; //Gruppe Starten!
             gmem[16*64 + 10 + cgroup] = 1;Link_Group = cgroup;group_update();
         ):(
             Link_Group = cgroup;// Gruppe teilnehmen
         );
     ):( //Eigene Gruppe angeklickt
           Link_Group = 0;
     );
  
  );
  
   cgroup = last_clicked_item - 3 - 16;
  last_clicked_item == 20 ? (
    gmem[16*64 + 10 + Link_Group] = 0;Link_Group = 0;
  );
  
  
  
  
  last_clicked_item == 21 ? zoom_off = 0;
  last_clicked_item == 22 ? zoom_off = 1;
 
 
  
  last_clicked_item == 23 ? helpshow = 1;
  
  helpshow == 1 ? (
  dmenu_zoom=dmenu_zoom*2;
  gfx_setfont(1,"Arial",12*dmenu_zoom,'b');
  gfx_r=0;gfx_g=0;gfx_b=0;gfx_a=0.7;
  gfx_rect(menu_x,menu_y+0,400*dmenu_zoom,145*dmenu_zoom);
  menu_x +=3;
  gfx_r=0.9;gfx_g=0.9;gfx_b=0.9;gfx_a=1;
  gfx_x = menu_x+3*dmenu_zoom; gfx_y = menu_y+3*dmenu_zoom;
  gfx_drawstr(setup_menu_name);
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 13*dmenu_zoom;
  gfx_drawstr("Version: "); gfx_drawstr(setup_menu_version);
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 20*dmenu_zoom;
  gfx_drawstr("Mouse modifier options:");
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 15*dmenu_zoom;
  gfx_drawstr("Fine tune knobs: [shift]");
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 13*dmenu_zoom;
  gfx_drawstr("Reset knobs: [ctrl] ([cmd] on mac)");
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 13*dmenu_zoom;
  gfx_drawstr("Link knobs on visible instances: [win] ([ctrl] on mac)");
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 13*dmenu_zoom;
  gfx_drawstr("Activate number typing: [alt]+[shift]");
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 23*dmenu_zoom;
  gfx_drawstr("Graphics by:");
  gfx_x = menu_x+3*dmenu_zoom; gfx_y += 13*dmenu_zoom;
  gfx_drawstr(setup_menu_graphics);
  );
);

function tk_extra_grouplinking()( // it seems to do nothing at all
  Link_Group == 0 ? (
    gmem[16*64 + 3] == 0 ? linkstart = 0;
    !mouse_cap ? (
      gmem[16*64 + 3] == 1 ? (linkstart == 0 ? link_old = slider(gmem[16*64 + 1]); linkstart = 1);
      gmem[16*64 + 3] == 1 ? (
        tmp_val = link_old +  gmem[16*64 + 2];
        slider(gmem[16*64 + 1]) = tmp_val;
        slider_automate(slider(gmem[16*64 + 1]));
        caller = 1;
      );
      gmem[16*64 + 3] == 2 ? (
      slider(gmem[16*64 + 1]) =  gmem[16*64 + 2];
      caller = 1;
    );
    );
  );
);

function effect_glow(d_alpha_min d_alpha_max d_alpha_speed)  instance(d_alpha d_alpha_add d_alpha_decrease d_alpha_min d_alpha_max d_alpha_speed) (
    gfx_a=1;
    d_alpha<=d_alpha_min?d_alpha_decrease=0;
    d_alpha>=d_alpha_max?d_alpha_decrease=1;
    d_alpha_decrease==1?d_alpha_add=-d_alpha_speed:d_alpha_add=d_alpha_speed;
    d_alpha=max(min(d_alpha+d_alpha_add,d_alpha_max),d_alpha_min);
    gfx_a=d_alpha;
);

function effect_oscillate(d_alpha_min d_alpha_max d_alpha_speed) instance(d_alpha d_alpha_add d_alpha_decrease d_alpha_min d_alpha_max d_alpha_speed osc_variable) (
    d_alpha<=d_alpha_min?d_alpha_decrease=0;
    d_alpha>=d_alpha_max?d_alpha_decrease=1;
    d_alpha_decrease==1?(d_alpha_add=0-d_alpha_speed):(d_alpha_add=d_alpha_speed);
    d_alpha=max(min(d_alpha+d_alpha_add,d_alpha_max),d_alpha_min);
	//d_alpha=d_alpha+d_alpha_add;
    d_alpha;
);

function sideright(d_sideoffset) (
	d_sideoffset=this.xIn+(this.size/2*this.scaling)+d_sideoffset;
);

function sideleft(d_sideoffset) (
	d_sideoffset=this.xIn-(this.size/2*this.scaling)-d_sideoffset;
);

function sideup(d_sideoffset) (
	d_sideoffset=this.yIn-(this.kheight/2*this.scaling)-d_sideoffset;
);

function sidedown(d_sideoffset) (
	d_sideoffset=this.yIn+(this.kheight/2*this.scaling)+d_sideoffset;
);